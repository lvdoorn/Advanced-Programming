\documentclass{article}

\usepackage{syntax}

\title{Advanced Programming Assignment 2 Report}
\author{Mihai Popovici \texttt{MTF422} \and Leendert van Doorn \texttt{XBT504}}

\begin{document}
\maketitle

\section{Parser Combinator Library}
We have chosen to use the parser combinator library \texttt{parsec}. This choice is mainly motivated by the large amount of support available for \texttt{parsec} compared to \texttt{readP}. A Google search for ``haskell parsec" returns about 311.000 results, whereas a search for ``haskell readP" returns only 15.800 results. Furthermore, on StackOverflow, ``haskell readP" returns 8 results, compared to 1.360 for ``haskell parsec".

\section{Final Grammar}
% https://tex.stackexchange.com/questions/24886/which-package-can-be-used-to-write-bnf-grammars

\setlength{\grammarparsep}{4pt plus 1pt minus 1pt} % increase separation between rules
\setlength{\grammarindent}{9em} % increase separation between LHS/RHS 

\begin{grammar}
	\let\syntleft\relax
	\let\syntright\relax
	
	<Expr> ::= Expr1 Expr'
	
	<Expr'> ::= `,' Expr
	\alt $\varepsilon$

	<Expr1> ::= Assignable
	\alt Assignment
	\alt Ident `(' Exprs `)'
	\alt `[' Exprs `]'
	\alt `[' ArrayFor `]'
		
	<Factor> ::= Number
	\alt Ident
	\alt String
	\alt `true'
	\alt `false'
	\alt `undefined'
	\alt `(' Expr `)'
	
	<Term> ::= Factor Term'
	
	<Term'> ::= `ProdOp' Factor Term'
	\alt $\varepsilon$
	
	<ProdOp> ::= `*'
	\alt `\%'
	
	<Comparable> ::= Term Comparable'
	
	<Comparable'> ::= `AddOp' Term Comparable'
	\alt $\varepsilon$
	
	<AddOp> ::= `+'
	\alt `-'
	
	<Assignable> ::= Comparable Assignable'
	
	<Assignable'> ::= `CompOp' Comparable Assignable'
	\alt $\varepsilon$
	
	
	<CompOp> ::= `<'
	\alt `==='
	
	<Assignment> ::= Ident `=' Assignment'
	
	<Assignment'> ::= Expr1
	\alt Assignment
	
	<Exprs> ::= Expr1 CommaExprs
	\alt $\varepsilon$	
	
	<CommaExprs> ::= `,' Expr1 CommaExprs
	\alt $\varepsilon$
	
	<ArrayFor> ::= `for' `(' Ident `of' Expr1 `)' ArrayCompr
	
	<ArrayIf> ::= `if' `(' Expr1 `)' ArrayCompr
	
	<ArrayCompr> ::= Expr1
	\alt ArrayFor
	\alt ArrayIf
	
	<Ident> ::= (see below)
	
	<Number> ::= (see below)
	
	<String> ::= (see below)
\end{grammar}


\section{Handling of Whitespace}
We have chosen the solution of skipping whitespace after each token and at the very beginning, as was recommended in the lecture. To implement this, we have made a function \texttt{whitespace} which will take a parser as input, run the parser, and then skip any remaining whitespace. In the top level function we skip whitespace at the very beginning of the input.

\section{Capabilities of Implementation}



\section{Assessment of Implementation}

\subsection{Objective Assessment}
In order to implement the parser, we first defined the grammar which can be seen as a pseudo-code for the solution. In order to express all the possible legit expressions we used recursion. So, the algorithm is relative straightforward, given an expression, we recursively asses the given input with the rules we set based on the final grammar. We think that this approach is suitable in that it avoids using complex data structures and keeps things simple.

The overall quality of the code is high: 
\begin{itemize}
	\item code consists of small functions named accordingly;
	\item we separated code in different files. This way we separated various concerns in submodules;
	\item code is indented and readable;
	\item we used hlint, ghc -W and OnlineTA to clean up the code.
\end{itemize}
 
To assess the robustness of our implementation, we have written a test suite consisting of both unit and end-to-end tests.
We have a pretty high test coverage of the solution, namely 98 tests to prove correctness of implementation. Parsers were tasted for concrete cases, whereas properties were tested using random generators (quickcheck).

\subsection{Value Judgement}


\section{How to Run the Code}
To run our code, execute \texttt{stack setup}, \texttt{stack install} and \texttt{stack test} in the top level \texttt{src} directory.



\end{document}